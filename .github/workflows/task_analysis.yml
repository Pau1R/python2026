name: Lesson Task Analysis

on:
  push:
    paths:
      - 'lessons/**/homework/**'
      - 'lessons/**/tasks/**'
  workflow_dispatch:
    inputs:
      base_sha:
        description: 'Optional base commit SHA for diff'
        required: false
        type: string
  workflow_call:
    inputs:
      base_sha:
        required: false
        type: string
    secrets:
      OPENROUTER_API_KEY:
        required: true
      TASKS_REPO_TOKEN:
        required: true

env:
  REPORT_AUTHOR_NAME: Lesson Bot
  REPORT_AUTHOR_EMAIL: lesson-bot@example.com
  TEMPLATE_URL: https://raw.githubusercontent.com/Pau1R/python2026/main/misc/task_autocheck_prompt.md

jobs:
  analyze:
    name: analyze
    if: github.repository != 'Pau1R/python2026'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect submission files
        id: detect
        shell: bash
        env:
          INPUT_BASE_SHA: ${{ inputs.base_sha || github.event.inputs.base_sha || '' }}
          EVENT_BEFORE: ${{ github.event.before || '' }}
        run: |
          set -euo pipefail

          echo "Detecting submission files"

          INPUT_BASE_SHA="${INPUT_BASE_SHA:-}"
          EVENT_BEFORE="${EVENT_BEFORE:-}"

          ZERO_SHA="0000000000000000000000000000000000000000"

          BASE=""
          if [[ -n "$INPUT_BASE_SHA" ]]; then
            BASE="$INPUT_BASE_SHA"
          elif [[ -n "$EVENT_BEFORE" && "$EVENT_BEFORE" != "$ZERO_SHA" ]]; then
            BASE="$EVENT_BEFORE"
          else
            BASE="$(git rev-list --max-parents=0 HEAD | tail -n 1)"
          fi

          echo "Resolved BASE=$BASE"

          mapfile -t NEW_SOLUTIONS < <(
            git diff --diff-filter=A --name-only "$BASE" HEAD -- \
              'lessons/**/homework/**' \
              'lessons/**/tasks/**' || true
          )

          if [[ "${#NEW_SOLUTIONS[@]}" -eq 0 ]]; then
            echo "No newly added solution files detected. Skipping analysis."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          MODE=""
          TASK=""
          SOLUTION_DIR=""
          declare -a MATCHED=()

          for FILE_PATH in "${NEW_SOLUTIONS[@]}"; do
            [[ -z "$FILE_PATH" ]] && continue

            RAW_PATH="$FILE_PATH"

            if [[ "$FILE_PATH" == \"*\" ]]; then
              FILE_PATH="${FILE_PATH#\"}"
              FILE_PATH="${FILE_PATH%\"}"
            fi

            FILE_PATH="$(printf '%b' "$FILE_PATH")"

            CURRENT_MODE=""
            CURRENT_TASK=""
            CURRENT_DIR=""

            if [[ "$FILE_PATH" =~ ^(lessons/[^/]+/homework)(/|$) ]]; then
              CURRENT_MODE="homework"
              CURRENT_DIR="${BASH_REMATCH[1]}"

            elif [[ "$FILE_PATH" =~ ^(lessons/[^/]+/tasks/[^/]+)(/|$) ]]; then
              CURRENT_MODE="task"
              CURRENT_DIR="${BASH_REMATCH[1]}"

              if [[ "$FILE_PATH" =~ task_([0-9]{1,2}) ]]; then
                CURRENT_TASK="${BASH_REMATCH[1]}"

              elif [[ "${CURRENT_DIR##*/}" =~ ([0-9]{1,2}) ]]; then
                CURRENT_TASK="${BASH_REMATCH[1]}"

              else
                shopt -s nullglob
                for DESC_FILE in "$CURRENT_DIR"/task_*.md; do
                  BASENAME="$(basename "$DESC_FILE")"
                  if [[ "$BASENAME" =~ task_([0-9]{1,2}) ]]; then
                    CURRENT_TASK="${BASH_REMATCH[1]}"
                    break
                  fi
                done
                shopt -u nullglob
              fi

            else
              continue
            fi

            if [[ -z "$MODE" ]]; then
              MODE="$CURRENT_MODE"
              TASK="$CURRENT_TASK"
              SOLUTION_DIR="$CURRENT_DIR"
            else
              if [[ "$MODE" != "$CURRENT_MODE" ]]; then
                echo "Found both homework and task submissions. Skipping analysis."
                echo "skip=true" >> "$GITHUB_OUTPUT"
                exit 0
              fi

              if [[ "$MODE" == "task" && -n "$TASK" && -n "$CURRENT_TASK" && "$TASK" != "$CURRENT_TASK" ]]; then
                echo "Found several task numbers in the same push. Skipping analysis."
                echo "skip=true" >> "$GITHUB_OUTPUT"
                exit 0
              fi

              if [[ "$SOLUTION_DIR" != "$CURRENT_DIR" ]]; then
                echo "Solution files live in different directories. Skipping analysis."
                echo "skip=true" >> "$GITHUB_OUTPUT"
                exit 0
              fi

              if [[ "$MODE" == "task" && -z "$TASK" && -n "$CURRENT_TASK" ]]; then
                TASK="$CURRENT_TASK"
              fi
            fi

            MATCHED+=("$FILE_PATH")
          done

          if [[ "${#MATCHED[@]}" -eq 0 ]]; then
            echo "No valid solution files detected. Skipping analysis."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Detected MODE=$MODE, TASK=$TASK, SOLUTION_DIR=$SOLUTION_DIR"

          mapfile -t ALL_CHANGES < <(git diff --name-only "$BASE" HEAD || true)

          declare -a TARGETS=()
          for FILE_PATH in "${MATCHED[@]}"; do
            [[ -z "$FILE_PATH" ]] && continue
            if [[ -f "$FILE_PATH" ]]; then
              TARGETS+=("$FILE_PATH")
            fi
          done

          echo "DEBUG DETECT: MODE=$MODE TASK=$TASK SOLUTION_DIR=$SOLUTION_DIR"
          echo "DEBUG DETECT: MATCHED (solutions):"
          printf '%s\n' "${MATCHED[@]}"
          echo "DEBUG DETECT: TARGETS (files to read):"
          printf '%s\n' "${TARGETS[@]}"

          {
            echo "skip=false"
            echo "mode=$MODE"
            echo "task=$TASK"
            echo "dir=$SOLUTION_DIR"
            echo "base=$BASE"

            printf 'solutions<<EOF\n%s\nEOF\n' "$(printf "%s\n" "${MATCHED[@]}" | sort -u)"
            printf 'files<<EOF\n%s\nEOF\n' "$(printf "%s\n" "${TARGETS[@]}" | sort -u)"
          } >> "$GITHUB_OUTPUT"

      - name: Resolve lesson metadata
        id: meta
        if: steps.detect.outputs.skip != 'true'
        shell: bash
        env:
          MODE: ${{ steps.detect.outputs.mode }}
          TASK: ${{ steps.detect.outputs.task }}
          DIR: ${{ steps.detect.outputs.dir }}
          REPOSITORY: ${{ github.repository }}
          TASKS_REPO_TOKEN: ${{ secrets.TASKS_REPO_TOKEN }}
        run: |
          set -euo pipefail

          OWNER="${REPOSITORY%%/*}"
          REPO_NAME="${REPOSITORY#*/}"
          if [[ -z "$OWNER" ]]; then
            OWNER="shared"
          fi

          echo "DEBUG META: OWNER='$OWNER', REPO_NAME='$REPO_NAME'" >&2

          STUDENT="$OWNER"

          NAME_MAPPING_URL="https://api.github.com/repos/Pau1R/python2026_tasks/contents/students/name_mapping.md"

          if [[ -n "${TASKS_REPO_TOKEN:-}" ]]; then
            MAP_CONTENT="$(
              curl -fsSL \
                -H "Authorization: Bearer $TASKS_REPO_TOKEN" \
                -H "Accept: application/vnd.github.raw" \
                "$NAME_MAPPING_URL" 2>/dev/null || true
            )"

            if [[ -n "$MAP_CONTENT" ]]; then
              echo "DEBUG META: mapping file loaded" >&2
              while IFS= read -r line; do
                [[ -z "$line" ]] && continue
                [[ "$line" =~ ^[[:space:]]*# ]] && continue

                echo "DEBUG META: raw line: '$line'" >&2

                if [[ "$line" =~ ^[[:space:]]*([^|[:space:]]+)[[:space:]]*\|[[:space:]]*([^[:space:]]+)[[:space:]]*$ ]]; then
                  SHORT_NAME="${BASH_REMATCH[1]}"
                  GITHUB_NAME="${BASH_REMATCH[2]}"

                  echo "DEBUG META: parsed SHORT_NAME='$SHORT_NAME', GITHUB_NAME='$GITHUB_NAME'" >&2

                  if [[ "$GITHUB_NAME" == "$OWNER" ]]; then
                    echo "DEBUG META: MATCH. OWNER='$OWNER' mapped to STUDENT='$SHORT_NAME'" >&2
                    STUDENT="$SHORT_NAME"
                    break
                  fi
                else
                  echo "DEBUG META: line did not match mapping regex" >&2
                fi
              done <<< "$MAP_CONTENT"
            else
              echo "DEBUG META: mapping file is empty or could not be fetched" >&2
            fi
          fi

          echo "DEBUG META: final STUDENT='$STUDENT'" >&2

          DIR_STRIPPED="$DIR"
          DIR_STRIPPED="${DIR_STRIPPED%\"}"
          DIR_STRIPPED="${DIR_STRIPPED#\"}"

          if [[ "$DIR_STRIPPED" != lessons/* ]]; then
            echo "DIR must start with lessons/: $DIR_STRIPPED" >&2
            exit 1
          fi

          LESSON_DIR="$(printf '%s' "$DIR_STRIPPED" | cut -d/ -f2)"
          if [[ -z "$LESSON_DIR" ]]; then
            echo "Could not determine LESSON_DIR from DIR=$DIR_STRIPPED" >&2
            exit 1
          fi

          if [[ "$LESSON_DIR" =~ ([0-9]+) ]]; then
            LESSON_NUM="${BASH_REMATCH[1]}"
          else
            LESSON_NUM="$LESSON_DIR"
          fi

          REL_WITH_LESSON="${DIR_STRIPPED#lessons/}"
          REMOTE_DIR="lessons/$REL_WITH_LESSON"

          if [[ "$MODE" == "homework" ]]; then
            DESCRIPTION="$DIR_STRIPPED/homework.md"
            REPORT_NAME="homework ${LESSON_NUM} ${STUDENT} result.md"
          elif [[ "$MODE" == "task" ]]; then
            DESCRIPTION="$DIR_STRIPPED/task ${LESSON_NUM}.${TASK} ${STUDENT}.md"
            REPORT_NAME="task ${LESSON_NUM}.${TASK} ${STUDENT} result.md"
          else
            echo "Unknown MODE: $MODE" >&2
            exit 1
          fi

          REPORT_PATH="$DIR_STRIPPED/$REPORT_NAME"

          if [[ ! -f "$DESCRIPTION" ]]; then
            echo "Description file does not exist: $DESCRIPTION" >&2
            exit 1
          fi

          {
            echo "description=$DESCRIPTION"
            echo "report=$REPORT_PATH"
            echo "report_name=$REPORT_NAME"
            echo "remote_dir=$REMOTE_DIR"
            echo "student=$STUDENT"
            echo "repo_name=$REPO_NAME"
            echo "owner=$OWNER"
          } >> "$GITHUB_OUTPUT"

      - name: Guard against existing report
        id: guard
        if: steps.detect.outputs.skip != 'true'
        shell: bash
        env:
          REPORT: ${{ steps.meta.outputs.report }}
          DESCRIPTION: ${{ steps.meta.outputs.description }}
          BASE: ${{ steps.detect.outputs.base }}
          REMOTE_DIR: ${{ steps.meta.outputs.remote_dir }}
          REPORT_NAME: ${{ steps.meta.outputs.report_name }}
          TASKS_REPO_TOKEN: ${{ secrets.TASKS_REPO_TOKEN }}
        run: |
          set -euo pipefail

          SKIP="false"

          if [[ -n "${BASE:-}" ]]; then
            if git diff --diff-filter=A --name-only "$BASE" HEAD -- "$DESCRIPTION" | grep -q .; then
              echo "Description file is newly added. Skipping analysis."
              SKIP="true"
            fi
          fi

          if [[ -z "${TASKS_REPO_TOKEN:-}" ]]; then
            echo "TASKS_REPO_TOKEN is required" >&2
            exit 1
          fi

          if [[ "$SKIP" == "false" ]]; then
            REMOTE_PATH="$REMOTE_DIR/$REPORT_NAME"
            export REMOTE_PATH
            ENCODED_REMOTE_PATH="$(python -c "import os, urllib.parse; remote_path = os.environ['REMOTE_PATH'].split('/'); encoded = '/'.join(urllib.parse.quote(part, safe='') for part in remote_path); print(encoded)")"

            API_URL="https://api.github.com/repos/Pau1R/python2026_tasks/contents/${ENCODED_REMOTE_PATH}"

            STATUS="$(
              curl -sS -o /tmp/teacher_report_check.json -w "%{http_code}" \
                -H "Authorization: Bearer ${TASKS_REPO_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                "$API_URL"
            )"

            if [[ "$STATUS" == "200" ]]; then
              echo "Teacher report already exists in python2026_tasks. Skipping analysis."
              SKIP="true"
            elif [[ "$STATUS" == "404" ]]; then
              :
            else
              echo "Unexpected status from GitHub API when checking teacher report: $STATUS" >&2
              cat /tmp/teacher_report_check.json >&2 || true
              exit 1
            fi
          fi

          if [[ "$SKIP" == "true" ]]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Read submission and description
        id: content
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        shell: bash
        env:
          FILES: ${{ steps.detect.outputs.files }}
          DESCRIPTION: ${{ steps.meta.outputs.description }}
        run: |
          set -euo pipefail

          {
            echo 'solution<<EOF'
            echo "DEBUG CONTENT: FILES raw:"
            printf '%s\n' "$FILES" >&2

            while IFS= read -r FILE; do
              FILE="${FILE//$'\r'/}"  # strip CR if any
              [[ -z "$FILE" ]] && continue
              echo "DEBUG CONTENT: processing FILE='$FILE'" >&2
              if [[ -f "$FILE" ]]; then
                echo "### $FILE"
                echo
                cat "$FILE"
                echo
              else
                echo "DEBUG CONTENT: file not found on disk: '$FILE'" >&2
              fi
            done <<< "$FILES"
            echo 'EOF'

            echo 'description<<EOF'
            cat "$DESCRIPTION"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Load analysis template
        id: template
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        shell: bash
        env:
          TEMPLATE_URL: ${{ env.TEMPLATE_URL }}
        run: |
          set -euo pipefail

          BODY="$(curl -fsSL "$TEMPLATE_URL" || true)"
          if [[ -z "$BODY" ]]; then
            echo "Template body is empty or could not be fetched" >&2
            exit 1
          fi

          {
            echo 'body<<EOF'
            printf '%s\n' "$BODY"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Compose prompt
        id: prompt
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        shell: bash
        env:
          TEMPLATE: ${{ steps.template.outputs.body }}
          DESCRIPTION: ${{ steps.content.outputs.description }}
          SOLUTION: ${{ steps.content.outputs.solution }}
        run: |
          set -euo pipefail

          echo "DEBUG PROMPT: DESCRIPTION length=${#DESCRIPTION}" >&2
          echo "DEBUG PROMPT: SOLUTION length=${#SOLUTION}" >&2
          echo "DEBUG PROMPT (first 500 chars of SOLUTION):" >&2
          printf '%s\n' "$SOLUTION" | head -c 500 >&2 || true
          echo >&2

          {
            echo 'prompt<<EOF'
            printf '%s\n' "$TEMPLATE"
            echo
            echo 'Task description:'
            printf '%s\n' "$DESCRIPTION"
            echo
            echo "Student's solution:"
            printf '%s\n' "$SOLUTION"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Run OpenRouter analysis
        id: openrouter
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        shell: python
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          PROMPT: ${{ steps.prompt.outputs.prompt }}
          TEMPERATURE: '0.1'
          MODELS_FILE_URL: https://raw.githubusercontent.com/Pau1R/python2026/main/misc/openrouter%20models.txt
        run: |
          import json
          import os
          import sys
          import urllib.request
          from typing import List

          api_key = os.environ.get("OPENROUTER_API_KEY")
          prompt = os.environ.get("PROMPT", "")
          models_file_url = os.environ.get("MODELS_FILE_URL")
          print(f"DEBUG OPENROUTER: prompt length={len(prompt)}", file=sys.stderr)
          print("DEBUG OPENROUTER: prompt preview:", file=sys.stderr)
          print(prompt[:800], file=sys.stderr)
          temperature = float(os.environ.get("TEMPERATURE", "0.1"))

          def load_models(url: str) -> List[str]:
            if not url:
              return []

            try:
              with urllib.request.urlopen(url, timeout=30) as resp:
                text = resp.read().decode("utf-8", errors="ignore")
            except Exception as exc:  # noqa: BLE001
              print(f"Failed to load models list from {url}: {exc}", file=sys.stderr)
              return []

            models: List[str] = []
            for line in text.splitlines():
              line = line.strip()
              if not line or line.startswith("#"):
                continue
              models.append(line)

            return models

          if not api_key:
            print("OPENROUTER_API_KEY is required", file=sys.stderr)
            sys.exit(1)

          if not prompt.strip():
            print("PROMPT is empty", file=sys.stderr)
            sys.exit(1)

          def call(model: str):
            url = "https://openrouter.ai/api/v1/chat/completions"
            data = {
              "model": model,
              "temperature": temperature,
              "messages": [
                {
                  "role": "system",
                  "content": "You are an assistant that reviews Python assignments and provides detailed, constructive feedback.",
                },
                {
                  "role": "user",
                  "content": prompt,
                },
              ],
            }

            req = urllib.request.Request(
              url,
              data=json.dumps(data).encode("utf-8"),
              headers={
                "Authorization": f"Bearer {api_key}",
                "Content-Type": "application/json",
                "HTTP-Referer": "https://github.com/Pau1R/python2026",
                "X-Title": "python2026-lesson-task-analysis",
              },
            )

            try:
              with urllib.request.urlopen(req, timeout=120) as resp:
                body = resp.read()
            except Exception as exc:  # noqa: BLE001
              print(f"Error calling OpenRouter with model {model}: {exc}", file=sys.stderr)
              return None

            try:
              obj = json.loads(body)
            except Exception as exc:  # noqa: BLE001
              print(f"Failed to parse OpenRouter response for model {model}: {exc}", file=sys.stderr)
              return None

            choices = obj.get("choices") or []
            if not choices:
              return None

            message = choices[0].get("message") or {}
            content = message.get("content") or ""
            return content.strip()

          models = load_models(models_file_url)

          if not models:
            print("No models available to call. Check misc/openrouter models.txt", file=sys.stderr)
            sys.exit(1)

          response = None
          for model in models:
            response = call(model)
            if response:
              break

          if not response:
            print("Failed to obtain response from OpenRouter", file=sys.stderr)
            sys.exit(1)

          github_output = os.environ.get("GITHUB_OUTPUT")
          if not github_output:
            print("GITHUB_OUTPUT is not set", file=sys.stderr)
            sys.exit(1)

          with open(github_output, "a", encoding="utf-8") as fh:
            fh.write("response<<EOF\n")
            fh.write(response)
            fh.write("\nEOF\n")

      - name: Save report locally
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        shell: bash
        env:
          REPORT: ${{ steps.meta.outputs.report }}
          RESPONSE: ${{ steps.openrouter.outputs.response }}
        run: |
          set -euo pipefail

          mkdir -p "$(dirname "$REPORT")"
          printf '%s\n' "$RESPONSE" > "$REPORT"
          echo "Saved report to $REPORT"

      - name: Commit report to student repo
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        shell: bash
        env:
          REPORT: ${{ steps.meta.outputs.report }}
          REPORT_NAME: ${{ steps.meta.outputs.report_name }}
          REPORT_AUTHOR_NAME: ${{ env.REPORT_AUTHOR_NAME }}
          REPORT_AUTHOR_EMAIL: ${{ env.REPORT_AUTHOR_EMAIL }}
        run: |
          set -euo pipefail

          git config user.name "$REPORT_AUTHOR_NAME"
          git config user.email "$REPORT_AUTHOR_EMAIL"

          git add "$REPORT"
          if git diff --cached --quiet; then
            echo "No changes to commit in student repo."
            exit 0
          fi

          git commit -m "Add ${REPORT_NAME}"
          git push

      - name: Upload analysis artifact
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: analysis-report
          path: ${{ steps.meta.outputs.report }}

      - name: Checkout teacher tasks repo
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        uses: actions/checkout@v4
        with:
          repository: Pau1R/python2026_tasks
          token: ${{ secrets.TASKS_REPO_TOKEN }}
          path: teacher-tasks

      - name: Copy report to teacher repo
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        shell: bash
        env:
          SOURCE_REPORT: ${{ steps.meta.outputs.report }}
          REMOTE_DIR: ${{ steps.meta.outputs.remote_dir }}
          REPORT_NAME: ${{ steps.meta.outputs.report_name }}
        run: |
          set -euo pipefail

          DEST_DIR="teacher-tasks/${REMOTE_DIR}"
          DEST_PATH="${DEST_DIR}/${REPORT_NAME}"

          mkdir -p "$DEST_DIR"

          if [[ -e "$DEST_PATH" ]]; then
            echo "Report already exists in teacher repo at $DEST_PATH. Not overwriting."
            exit 0
          fi

          cp "$SOURCE_REPORT" "$DEST_PATH"
          echo "Copied report to $DEST_PATH"

      - name: Commit report to teacher repo
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        shell: bash
        env:
          REMOTE_DIR: ${{ steps.meta.outputs.remote_dir }}
          REPORT_NAME: ${{ steps.meta.outputs.report_name }}
          REPORT_AUTHOR_NAME: ${{ env.REPORT_AUTHOR_NAME }}
          REPORT_AUTHOR_EMAIL: ${{ env.REPORT_AUTHOR_EMAIL }}
        run: |
          set -euo pipefail

          cd teacher-tasks

          git config user.name "$REPORT_AUTHOR_NAME"
          git config user.email "$REPORT_AUTHOR_EMAIL"

          git add "${REMOTE_DIR}/${REPORT_NAME}"
          if git diff --cached --quiet; then
            echo "No changes to commit in teacher repo."
            exit 0
          fi

          git commit -m "Add ${REPORT_NAME}"
          git push
