name: Lesson Task Analysis

on:
  push:
    paths:
      - "students/**/lessons/**/homework/**"
      - "students/**/lessons/**/tasks/**"
  workflow_dispatch:
    inputs:
      base_sha:
        description: Optional base commit SHA to diff against
        required: false
        type: string
  workflow_call:
    inputs:
      base_sha:
        description: Optional base commit SHA to diff against
        required: false
        type: string
    secrets:
      OPENROUTER_API_KEY:
        required: true
      TASKS_REPO_TOKEN:
        required: true

env:
  REPORT_AUTHOR_NAME: Lesson Bot
  REPORT_AUTHOR_EMAIL: lesson-bot@example.com
  TEMPLATE_URL: https://raw.githubusercontent.com/Pau1R/python2026/main/misc/task_autocheck_prompt.md
  OPENROUTER_MODEL: x-ai/grok-4.1-fast:free

jobs:
  analyze:
    if: github.repository != 'Pau1R/python2026'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect submission files
        id: detect
        shell: bash
        env:
          INPUT_BASE_SHA: ${{ inputs.base_sha || github.event.inputs.base_sha || '' }}
          EVENT_BEFORE: ${{ github.event.before || '' }}
        run: |
          set -euo pipefail

          BASE="$INPUT_BASE_SHA"
          if [[ -z "$BASE" ]]; then
            BASE="$EVENT_BEFORE"
          fi
          if [[ -z "$BASE" || "$BASE" == "0000000000000000000000000000000000000000" ]]; then
            BASE="$(git rev-list --max-parents=0 HEAD)"
          fi

          mapfile -t NEW_SOLUTIONS < <(
            git diff --diff-filter=A --name-only "$BASE" HEAD -- \
              'lessons/**/homework/**' \
              'lessons/**/tasks/**' || true
          )

          if [[ "${#NEW_SOLUTIONS[@]}" -eq 0 ]]; then
            echo "No newly added solution files detected. Skipping analysis."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          MODE=""
          TASK=""
          SOLUTION_DIR=""
          declare -a MATCHED=()
          for FILE_PATH in "${NEW_SOLUTIONS[@]}"; do
            [[ -z "$FILE_PATH" ]] && continue
            RAW_PATH="$FILE_PATH"
            if [[ "$FILE_PATH" == \"*\" ]]; then
              FILE_PATH="${FILE_PATH#\"}"
              FILE_PATH="${FILE_PATH%\"}"
            fi
            CURRENT_MODE=""
            CURRENT_TASK=""
            CURRENT_DIR=""
            if [[ "$FILE_PATH" =~ ^(lessons/[^/]+/homework)(/|$) ]]; then
              CURRENT_MODE="homework"
              CURRENT_DIR="${BASH_REMATCH[1]}"
            elif [[ "$FILE_PATH" =~ ^(lessons/[^/]+/tasks/[^/]+)(/|$) ]]; then
              CURRENT_MODE="task"
              CURRENT_DIR="${BASH_REMATCH[1]}"
              if [[ "$FILE_PATH" =~ task_([0-9]{1,2}) ]]; then
                CURRENT_TASK="${BASH_REMATCH[1]}"
              elif [[ "${CURRENT_DIR##*/}" =~ ([0-9]{1,2}) ]]; then
                CURRENT_TASK="${BASH_REMATCH[1]}"
              else
                shopt -s nullglob
                for DESC_FILE in "$CURRENT_DIR"/task_*.md; do
                  BASENAME="$(basename "$DESC_FILE")"
                  if [[ "$BASENAME" =~ task_([0-9]{1,2}) ]]; then
                    CURRENT_TASK="${BASH_REMATCH[1]}"
                    break
                  fi
                done
                shopt -u nullglob
              fi
            else
              continue
            fi

            if [[ -z "$MODE" ]]; then
              MODE="$CURRENT_MODE"
              TASK="$CURRENT_TASK"
              SOLUTION_DIR="$CURRENT_DIR"
            else
              if [[ "$MODE" != "$CURRENT_MODE" ]]; then
                echo "Found both homework and task submissions. Skipping analysis."
                echo "skip=true" >> "$GITHUB_OUTPUT"
                exit 0
              fi
              if [[ "$MODE" == "task" && -n "$TASK" && -n "$CURRENT_TASK" && "$TASK" != "$CURRENT_TASK" ]]; then
                echo "Found several task numbers in the same push. Skipping analysis."
                echo "skip=true" >> "$GITHUB_OUTPUT"
                exit 0
              fi
              if [[ "$SOLUTION_DIR" != "$CURRENT_DIR" ]]; then
                echo "Solution files live in different directories. Skipping analysis."
                echo "skip=true" >> "$GITHUB_OUTPUT"
                exit 0
              fi
              if [[ "$MODE" == "task" && -z "$TASK" && -n "$CURRENT_TASK" ]]; then
                TASK="$CURRENT_TASK"
              fi
            fi

            MATCHED+=("$FILE_PATH")
          done

          if [[ "${#MATCHED[@]}" -eq 0 ]]; then
            echo "No valid solution files detected. Skipping analysis."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          mapfile -t ALL_CHANGES < <(git diff --name-only "$BASE" HEAD || true)
          declare -a TARGETS=()
          for CHANGED_PATH in "${ALL_CHANGES[@]}"; do
            [[ -z "$CHANGED_PATH" ]] && continue
            if [[ "$CHANGED_PATH" == "$SOLUTION_DIR" || "$CHANGED_PATH" == "$SOLUTION_DIR"/* ]]; then
              if [[ -f "$CHANGED_PATH" ]]; then
                TARGETS+=("$CHANGED_PATH")
              fi
            fi
          done

          {
            echo "skip=false"
            echo "mode=$MODE"
            echo "task=$TASK"
            echo "dir=$SOLUTION_DIR"
            echo "base=$BASE"
            printf 'solutions<<EOF\n%s\nEOF\n' "$(printf "%s\n" "${MATCHED[@]}" | sort -u)"
            printf 'files<<EOF\n%s\nEOF\n' "$(printf "%s\n" "${TARGETS[@]}" | sort -u)"
          } >> "$GITHUB_OUTPUT"

      - name: Resolve lesson metadata
        id: meta
        if: steps.detect.outputs.skip != 'true'
        shell: bash
        env:
          MODE: ${{ steps.detect.outputs.mode }}
          TASK: ${{ steps.detect.outputs.task }}
          DIR: ${{ steps.detect.outputs.dir }}
          REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          STUDENT="${REPOSITORY#*/}"
          if [[ -z "$STUDENT" ]]; then
            STUDENT="shared"
          fi

          if [[ "$DIR" != lessons/* ]]; then
            echo "Unexpected directory layout for $DIR" >&2
            exit 1
          fi

          LESSON_DIR="$(printf "%s" "$DIR" | cut -d/ -f2)"
          if [[ -z "$LESSON_DIR" ]]; then
            echo "Unable to determine lesson from $DIR" >&2
            exit 1
          fi

          if [[ "$LESSON_DIR" =~ ([0-9]+) ]]; then
            LESSON_NUM="${BASH_REMATCH[1]}"
          else
            LESSON_NUM="$LESSON_DIR"
          fi

          REL_WITH_LESSON="${DIR#lessons/}"

          REMOTE_DIR="lessons/$REL_WITH_LESSON"

          if [[ "$MODE" == "homework" ]]; then
            DESCRIPTION="$DIR/homework.md"
            REPORT_NAME="homework ${LESSON_NUM} ${STUDENT} result.md"
          else
            DESCRIPTION="$DIR/task_${TASK}.md"
            REPORT_NAME="task ${LESSON_NUM}.${TASK} ${STUDENT} result.md"
          fi

          REPORT_PATH="$DIR/$REPORT_NAME"

          if [[ ! -f "$DESCRIPTION" ]]; then
            echo "Expected description file $DESCRIPTION not found." >&2
            exit 1
          fi

          {
            echo "description=$DESCRIPTION"
            echo "report=$REPORT_PATH"
            echo "report_name=$REPORT_NAME"
            echo "remote_dir=$REMOTE_DIR"
            echo "student=$STUDENT"
          } >> "$GITHUB_OUTPUT"

      - name: Guard against existing report
        id: guard
        if: steps.detect.outputs.skip != 'true'
        shell: bash
        env:
          REPORT: ${{ steps.meta.outputs.report }}
          DESCRIPTION: ${{ steps.meta.outputs.description }}
          BASE: ${{ steps.detect.outputs.base }}
          REMOTE_DIR: ${{ steps.meta.outputs.remote_dir }}
          REPORT_NAME: ${{ steps.meta.outputs.report_name }}
          REPORT_PATH: ${{ steps.meta.outputs.report }}
          TASKS_REPO_TOKEN: ${{ secrets.TASKS_REPO_TOKEN }}
        run: |
          set -euo pipefail

          if [[ -n "$BASE" ]]; then
            if git diff --diff-filter=A --name-only "$BASE" HEAD -- "$DESCRIPTION" | grep -q .; then
              echo "Description file $DESCRIPTION is newly added. Skipping analysis."
              echo "skip=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          if [[ -z "${TASKS_REPO_TOKEN:-}" ]]; then
            echo "Missing TASKS_REPO_TOKEN secret." >&2
            exit 1
          fi

          REMOTE_PATH="$REMOTE_DIR/$REPORT_NAME"
          export REMOTE_PATH
          ENCODED_REMOTE_PATH="$(python -c "import os, urllib.parse; remote_path = os.environ['REMOTE_PATH'].split('/'); encoded = '/'.join(urllib.parse.quote(part, safe='') for part in remote_path); print(encoded)")"

          API_URL="https://api.github.com/repos/Pau1R/python2026_tasks/contents/$ENCODED_REMOTE_PATH"
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer $TASKS_REPO_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "$API_URL")

          if [[ "$HTTP_STATUS" == "200" ]]; then
            echo "Teacher report $REMOTE_PATH already exists. Skipping analysis."
            echo "skip=true" >> "$GITHUB_OUTPUT"
          elif [[ "$HTTP_STATUS" == "404" ]]; then
            echo "skip=false" >> "$GITHUB_OUTPUT"
          else
            echo "Failed to check teacher repo for $REMOTE_PATH (status $HTTP_STATUS)." >&2
            exit 1
          fi

      - name: Read submission and description
        id: content
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        shell: bash
        env:
          FILES: ${{ steps.detect.outputs.files }}
          DESCRIPTION: ${{ steps.meta.outputs.description }}
        run: |
          set -euo pipefail

          {
            echo "solution<<EOF"
            while IFS= read -r FILE; do
              [[ -z "$FILE" ]] && continue
              if [[ -f "$FILE" ]]; then
                echo "### $FILE"
                echo
                cat "$FILE"
                echo
              fi
            done <<<"$FILES"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          {
            echo "description<<EOF"
            cat "$DESCRIPTION"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Load analysis template
        id: template
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        shell: bash
        env:
          TEMPLATE_URL: ${{ env.TEMPLATE_URL }}
        run: |
          set -euo pipefail

          TEMPLATE_CONTENT="$(curl -fsSL "$TEMPLATE_URL")"
          if [[ -z "$TEMPLATE_CONTENT" ]]; then
            echo "Failed to download template from $TEMPLATE_URL" >&2
            exit 1
          fi

          {
            echo "body<<EOF"
            printf "%s\n" "$TEMPLATE_CONTENT"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Compose prompt
        id: prompt
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        shell: bash
        env:
          TEMPLATE: ${{ steps.template.outputs.body }}
          DESCRIPTION: ${{ steps.content.outputs.description }}
          SOLUTION: ${{ steps.content.outputs.solution }}
        run: |
          set -euo pipefail

          {
            echo "prompt<<EOF"
            printf "%s\n\n" "$TEMPLATE"
            echo "Task description:"
            echo "---"
            printf "%s\n" "$DESCRIPTION"
            echo "---"
            echo
            echo "Student's solution:"
            echo "---"
            printf "%s\n" "$SOLUTION"
            echo "---"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Run OpenRouter analysis
        id: openrouter
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          PROMPT: ${{ steps.prompt.outputs.prompt }}
          TEMPERATURE: "0.1"
          MODEL: ${{ env.OPENROUTER_MODEL }}
        shell: python
        run: |
          import json
          import os
          import urllib.error
          import urllib.request

          api_key = os.environ.get("OPENROUTER_API_KEY")
          if not api_key:
              raise SystemExit("Missing OPENROUTER_API_KEY secret.")

          prompt = os.environ["PROMPT"]
          temperature = float(os.environ.get("TEMPERATURE", "0.1"))

          primary_model = os.environ.get("MODEL", "x-ai/grok-4.1-fast:free")
          fallback_model = "openai/gpt-oss-20b:free"

          def call_openrouter(model: str) -> str:
              payload = {
                  "model": model,
                  "messages": [
                      {
                          "role": "system",
                          "content": (
                              "You assist instructors by reviewing Python assignments. "
                              "Return actionable, concise feedback."
                          ),
                      },
                      {"role": "user", "content": prompt},
                  ],
                  "temperature": temperature,
              }

              req = urllib.request.Request(
                  "https://openrouter.ai/api/v1/chat/completions",
                  data=json.dumps(payload).encode("utf-8"),
                  headers={
                      "Content-Type": "application/json",
                      "Authorization": f"Bearer {api_key}",
                      "HTTP-Referer": "https://github.com/Pau1R/python2026",
                      "X-Title": "Lesson Task Analysis Workflow",
                  },
              )

              try:
                  with urllib.request.urlopen(req, timeout=90) as resp:
                      body = resp.read()
              except urllib.error.HTTPError as exc:
                  detail = exc.read().decode("utf-8", errors="replace")
                  raise RuntimeError(f"OpenRouter request failed: {exc.code} {detail}")
              except urllib.error.URLError as exc:
                  raise RuntimeError(f"OpenRouter request failed: {exc.reason}")

              data = json.loads(body)
              choices = data.get("choices") or []
              if not choices:
                  raise RuntimeError("OpenRouter response missing choices")

              return choices[0]["message"].get("content", "").rstrip()

          errors = []
          content = ""
          for model in (primary_model, fallback_model):
              try:
                  content = call_openrouter(model)
                  break
              except RuntimeError as exc:
                  errors.append(f"{model}: {exc}")

          if not content:
              message = "OpenRouter request failed for all models: " + " | ".join(errors)
              raise SystemExit(message)

          output_path = os.environ["GITHUB_OUTPUT"]
          with open(output_path, "a", encoding="utf-8") as fh:
              fh.write("response<<EOF\n")
              fh.write(content)
              fh.write("\nEOF\n")

      - name: Save report locally
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        shell: bash
        env:
          REPORT: ${{ steps.meta.outputs.report }}
          RESPONSE: ${{ steps.openrouter.outputs.response }}
        run: |
          set -euo pipefail
          printf "%s\n" "$RESPONSE" > "$REPORT"
          echo "Report saved to $REPORT"

      - name: Commit report to student repo
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        shell: bash
        env:
          REPORT: ${{ steps.meta.outputs.report }}
          REPORT_NAME: ${{ steps.meta.outputs.report_name }}
          REPORT_AUTHOR_NAME: ${{ env.REPORT_AUTHOR_NAME }}
          REPORT_AUTHOR_EMAIL: ${{ env.REPORT_AUTHOR_EMAIL }}
        run: |
          set -euo pipefail
          git config user.name "$REPORT_AUTHOR_NAME"
          git config user.email "$REPORT_AUTHOR_EMAIL"
          git add "$REPORT"
          if git diff --cached --quiet; then
            echo "No report changes to commit in student repo."
            exit 0
          fi
          git commit -m "Add $REPORT_NAME"
          git push

      - name: Upload analysis artifact
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: analysis-report
          path: ${{ steps.meta.outputs.report }}

      - name: Checkout teacher tasks repo
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        uses: actions/checkout@v4
        with:
          repository: Pau1R/python2026_tasks
          token: ${{ secrets.TASKS_REPO_TOKEN }}
          path: teacher-tasks

      - name: Copy report to teacher repo
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        shell: bash
        env:
          SOURCE_REPORT: ${{ steps.meta.outputs.report }}
          REMOTE_DIR: ${{ steps.meta.outputs.remote_dir }}
          REPORT_NAME: ${{ steps.meta.outputs.report_name }}
        run: |
          set -euo pipefail
          DEST_DIR="teacher-tasks/$REMOTE_DIR"
          DEST_PATH="$DEST_DIR/$REPORT_NAME"
          mkdir -p "$DEST_DIR"
          if [[ -f "$DEST_PATH" ]]; then
            echo "Teacher report $DEST_PATH already exists. Skipping copy to avoid overwriting."
            exit 0
          fi
          cp "$SOURCE_REPORT" "$DEST_PATH"

      - name: Commit report to teacher repo
        if: steps.detect.outputs.skip != 'true' && steps.guard.outputs.skip != 'true'
        shell: bash
        env:
          REMOTE_DIR: ${{ steps.meta.outputs.remote_dir }}
          REPORT_NAME: ${{ steps.meta.outputs.report_name }}
          REPORT_AUTHOR_NAME: ${{ env.REPORT_AUTHOR_NAME }}
          REPORT_AUTHOR_EMAIL: ${{ env.REPORT_AUTHOR_EMAIL }}
        run: |
          set -euo pipefail
          cd teacher-tasks
          git config user.name "$REPORT_AUTHOR_NAME"
          git config user.email "$REPORT_AUTHOR_EMAIL"
          git add "$REMOTE_DIR/$REPORT_NAME"
          if git diff --cached --quiet; then
            echo "No report changes to commit."
            exit 0
          fi
          git commit -m "Add $REPORT_NAME"
          git push
