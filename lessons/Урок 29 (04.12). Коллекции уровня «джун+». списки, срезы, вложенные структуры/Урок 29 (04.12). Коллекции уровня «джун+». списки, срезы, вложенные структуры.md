# Урок 29. Коллекции уровня «джун+». списки, срезы, вложенные структуры

## Цель урока
Студент поймет, почему список считается главной коллекцией начинающего разработчика и научится уверенно применять его в задачах. Узнает, как рассчитывать индексы и срезы, чтобы быстро доставать нужные элементы. Отработает основные методы изменения списков. Разберется, как читать и строить вложенные структуры для хранения табличных данных.

## Ключевые понятия
- Список
  - Упорядоченная изменяемая коллекция значений.
- Индексация
  - Позиции элементов, которые можно считать слева направо и справа налево.
- Срез
  - Способ получить подсписок через форму start:stop:step.
- Мутация
  - Изменение списка методами append, extend, insert, remove, pop, clear.
- Вложенная структура
  - Список списков или список словарей, который хранит данные с несколькими уровнями вложенности.

## Содержание темы

### Блок 1. Знакомство со списками

#### Объяснение
Список подходит, когда нужно хранить упорядоченную коллекцию данных, которую можно изменять. Его элементы отделяются запятыми в квадратных скобках. Важно понимать, что список допускает значения разных типов и может быть пустым. Обращение по индексу позволяет получить конкретный элемент, а отрицательные индексы идут с конца. Для перебора чаще всего используют цикл for. Список удобно измерять функцией len, чтобы не выйти за границы.

#### Примеры кода
```python
# создаем список покупок и выводим базовые свойства
shopping_list = ["молоко", "яблоки", "хлеб"]
print(len(shopping_list))         # 3 элемента в списке
print(shopping_list[0])           # первый элемент
print(shopping_list[-1])          # последний элемент
```

```python
# нумерованный вывод позиций с помощью enumerate
shopping_list = ["молоко", "яблоки", "хлеб"]
for index, item in enumerate(shopping_list, start=1):
    print(f"{index}. {item}")     # читаемый формат списка
```
Эти примеры показывают, как получать длину списка, отдельные элементы и аккуратно перебираť содержимое.

#### Примеры из реальной жизни
- Список покупок перед походом в магазин, который можно дополнять и сокращать по мере планирования бюджета.
- Очередь дел на день, где важно помнить порядок выполнения задач.

### Блок 2. Индексация и срезы

#### Объяснение
Каждый элемент списка имеет индекс. Слева направо индексы начинаются с нуля, справа налево используються отрицательные значения. Срез позволяет получить новый список без ручного цикла. Запись list[start:stop:step] возвращает элементы от start до stop не включительно, двигаясь с шагом step. Пропущенные границы означают начало или конец списка, а отрицательный шаг переворачивает порядок. Срезы удобны для копирования, отделения части данных, фильтрации шагом.

#### Примеры кода
```python
# извлекаем полезные подсписки
numbers = [3, 5, 8, 13, 21, 34]
print(numbers[:3])     # первые три элемента
print(numbers[-3:])    # последние три элемента
print(numbers[::2])    # каждый второй элемент
```

```python
# инверсия и копирование
numbers = [3, 5, 8, 13, 21, 34]
reversed_numbers = numbers[::-1]
copy_numbers = numbers[:]
print(reversed_numbers)
print(copy_numbers)
```
Такой подход избавляет от ручных циклов и помогает избежать ошибок с границами при работе с подсписками.

#### Примеры из реальной жизни
- Получить последние три дня продаж, чтобы оценить текущий спрос.
- Отобрать каждый второй кадр из видеоряда для быстрого предпросмотра.

### Блок 3. Мутация и методы списков

#### Объяснение
Мутация меняет содержимое списка на месте. Метод append добавляет элемент в конец, extend расширяет список другим списком, insert вставляет по индексу. Удаление выполняют remove (по значению) и pop (по индексу, плюс возвращает удаленный элемент). Clear очищает список целиком. Нужно помнить, что методы чаще всего возвращают None, а сам список изменяется. При работе с копиями важно делать срез или list(), иначе изменения отразятся на всех ссылках.

#### Примеры кода
```python
# план задач на день с добавлением и удалением
plan = ["зарядка", "завтрак", "учеба"]
plan.append("прогулка")            # добавляем активность в конец
plan.insert(1, "проверка почты")   # вставляем вторым пунктом
print(plan)
```

```python
# обработка выполненных задач
plan = ["зарядка", "проверка почты", "учеба", "прогулка"]
done = plan.pop(0)                  # убираем первый пункт
plan.remove("учеба")               # удаляем по значению
print(done)
print(plan)
```
Эти методы позволяют гибко управлять содержимым без создания нового списка каждый раз.

#### Примеры из реальной жизни
- Изменить расписание занятий, когда преподаватель переносит лекцию или добавляет консультацию.
- Формировать список ингредиентов по мере готовки блюда, убирая то, что уже добавлено.

### Блок 4. Вложенные структуры

#### Объяснение
Списки могут содержать другие списки или словари, что позволяет хранить табличные данные. Например, расписание можно представить списком словарей, где каждый словарь описывает урок. Для доступа приходится указывать цепочку индексов и ключей. Чтобы избежать ошибок, нужно проверять длину и наличие ключей. Перебор вложенных структур выполняют вложенными циклами или через распаковку.

#### Примеры кода
```python
# таблица оценок как список списков
scores = [
    ["Анна", 5, 4, 5],
    ["Игорь", 4, 4, 3]
]
for student in scores:
    name = student[0]
    average = sum(student[1:]) / len(student[1:])
    print(name, average)
```

```python
# расписание как список словарей
schedule = [
    {"day": "Понедельник", "time": "10:00", "topic": "Списки"},
    {"day": "Среда", "time": "12:00", "topic": "Срезы"}
]
for lesson in schedule:
    print(f"{lesson['day']} {lesson['time']} — {lesson['topic']}")
```
Перед обращением к глубоко вложенным элементам стоит убедиться, что индекс или ключ существует, иначе программа получит ошибку.

#### Примеры из реальной жизни
- Хранение расписания группы с указанием дня, времени и темы занятия.
- Таблица расходов, где для каждой покупки записываются сумма, категория и дата в виде словаря.

## Объединяющий пример
Задача: собрать недельное расписание занятий, сгруппировать их по дням, быстро получить актуальные сегменты и обновить данные после изменений.

Шаги решения:
1. Создать список словарей, каждый словарь описывает урок.
2. Получить срез с первыми тремя уроками для ближнего плана.
3. Добавить новый урок и удалить старый, чтобы расписание оставалось актуальным.
4. Разбить расписание по дням в отдельный список списков для печати.

```python
# исходное расписание
lessons = [
    {"day": "Пн", "time": "10:00", "topic": "Списки"},
    {"day": "Ср", "time": "12:00", "topic": "Срезы"},
    {"day": "Пт", "time": "15:00", "topic": "Мутации"},
    {"day": "Сб", "time": "11:00", "topic": "Вложенные структуры"}
]

upcoming = lessons[:3]                    # ближайшие уроки на неделю
lessons.append({"day": "Вс", "time": "13:00", "topic": "Практика"})
removed = lessons.pop(1)                  # отменяем урок среды

print("Отменен", removed)
print("Новый список:")
for lesson in lessons:
    print(lesson)
```
Код показывает, как применять срезы и методы мутации одновременно.

```python
# группируем по дням недели
by_day = []
for lesson in lessons:
    entry = [lesson["day"], lesson["time"], lesson["topic"]]
    by_day.append(entry)

for day_info in by_day:
    print(f"{day_info[0]}: {day_info[2]} в {day_info[1]}")
```
Финальный блок демонстрирует переход от списка словарей к списку списков для печати и тренирует доступ к вложенным структурам. После выполнения примера студент видит, как блоки темы работают вместе: базовые списки, срезы, методы мутации и вложенные данные применяются в одной задаче.
