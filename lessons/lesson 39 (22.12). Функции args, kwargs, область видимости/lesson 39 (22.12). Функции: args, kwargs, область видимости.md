# Урок 39 (22.12). Практика по `*args`, `**kwargs` и областям видимости

Занятие построено вокруг четырех блоков. Каждый блок повторяет кусок материала урока 35, расширяет его практикой и заканчивается самостоятельной задачей. После выполнения всех заданий проведем общий разбор решений и типичных ошибок.

## Блок 1. `*args` как гибкий сборщик позиционных аргументов

```python
def normalize_scores(*scores):
    if not scores:
        raise ValueError("Нужно передать хотя бы один балл")

    max_score = max(scores)
    normalized = []
    for score in scores:
        normalized.append(round(score / max_score * 100, 1))
    return tuple(normalized)


print(normalize_scores(7, 9, 6))
```

- Что передаем: любое количество чисел. Вызов `normalize_scores(7, 9, 6)` превращает их в кортеж `scores=(7, 9, 6)`.
- Что делает код: проверяет пустой ввод, ищет максимум, прогоняет цикл и накапливает проценты в списке. Массив переводим в кортеж, чтобы подчеркнуть неизменность результата.
- Что печатается: `(77.8, 100.0, 66.7)`. Значения округлены, поэтому объясните, зачем нам `round`.
- Подводный камень: вызов без аргументов. В примере это явно отловлено и поднимается исключение, чтобы не получить `ValueError`/`ZeroDivisionError` глубже.

**Самостоятельное задание:** подробнее в файле «lesson 39 (22.12). Самостоятельные задания.md», раздел «Блок 1. `mean_abs_deviation`».

## Блок 2. `**kwargs` как канал метаданных

```python
def build_profile(**kwargs):
    name = kwargs.get("name", "Не указан")
    role = kwargs.get("role", "student")
    allowed_keys = {"city", "stack", "level"}

    extras = {key: value for key, value in kwargs.items() if key in allowed_keys}
    return {
        "name": name,
        "role": role,
        "meta": extras,
    }


print(build_profile(name="Ирина", city="Казань", stack=["Python", "SQL"]))
```

- Что передаем: именованные аргументы, которые попадут в словарь `kwargs`.
- Что делает код: берет обязательные поля через `get`, фильтрует допустимые ключи в `extras`, собирает новый словарь. Обратите внимание, что никакие неожиданные аргументы не проходят дальше.
- Что печатается: `{'name': 'Ирина', 'role': 'student', 'meta': {'city': 'Казань', 'stack': ['Python', 'SQL']}}`.
- Подводный камень: попытка обращаться к `kwargs.role` вместо словарного синтаксиса. Еще одна ошибка — использовать `kwargs` напрямую при формировании результата и тем самым утянуть служебные ключи.

**Самостоятельное задание:** см. подробное описание в файле «lesson 39 (22.12). Самостоятельные задания.md», раздел «Блок 2. `prepare_request`».

## Блок 3. Комбинируем `*args`, `**kwargs` и распаковку при вызове

```python
def log_event(event_type, *details, **options):
    prefix = options.get("prefix", "[LOG]")
    if options.get("uppercase"):
        details = tuple(str(item).upper() for item in details)

    line = " ".join(str(item) for item in details)
    print(f"{prefix} {event_type}: {line}")


entries = ("login", "user42")
extra_options = {"prefix": "[SECURITY]", "uppercase": True}

log_event("AUTH", *entries, ip="127.0.0.1")
log_event("AUTH", *entries, **extra_options)
```

- Что передаем: обязательный `event_type`, произвольные позиционные детали и именованные опции.
- Что делает код: читает настройку `prefix`, при флаге `uppercase` модифицирует кортеж `details`, собирает строку и печатает ее. Второй вызов демонстрирует двойную распаковку — сначала `*entries`, затем `**extra_options`.
- Что печатается: `[LOG] AUTH: login user42 ip=127.0.0.1` и `[SECURITY] AUTH: LOGIN USER42`.
- Подводный камень: порядок аргументов при вызове (позиционные до именованных) и несовместимые ключи в `extra_options`. Еще одно частое недоразумение — попытка менять `details` как список без преобразования.

**Самостоятельное задание:** полное ТЗ находится в файле «lesson 39 (22.12). Самостоятельные задания.md», раздел «Блок 3. `dispatch`».

## Блок 4. Область видимости, `global` и `nonlocal`

```python
total_calls = 0


def make_power_tracker(power):
    count = 0

    def apply(value):
        global total_calls
        nonlocal count

        total_calls += 1
        count += 1
        result = value ** power
        print(f"Вызов #{count}: {value}^{power} = {result}")
        return result

    return apply


square = make_power_tracker(2)
cube = make_power_tracker(3)

square(4)
square(5)
cube(2)
print("Всего вызовов:", total_calls)
```

- Что происходит внутри `make_power_tracker`: переменная `count` живет в замыкании. На каждом вызове `apply` мы увеличиваем ее через `nonlocal`.
- Зачем `global total_calls`: чтобы вести общий счетчик всех вызовов любых трекеров и обновлять одну переменную на уровне модуля.
- Результат: функции `square` и `cube` имеют независимую локальную историю (`count`), но общий глобальный счетчик. После трех вызовов печатается `Всего вызовов: 3`.
- Подводный камень: без `nonlocal` каждая попытка поменять `count` создавала бы новую локальную переменную и мы потеряли бы счетчик. Без `global` переменная `total_calls` осталась бы неизменной.

**Самостоятельное задание:** см. файл «lesson 39 (22.12). Самостоятельные задания.md», раздел «Блок 4. `make_budget_tracker`».

## Общий разбор

После выполнения четырех заданий:
1. Проверьте тестовые кейсы: пустые `*args`, неожиданные ключи в `**kwargs`, конфликты имен, корректность распаковки.
2. Обсудите, где понадобилось вводить проверки и почему лучше падать с понятной ошибкой.
3. Сравните подходы к хранению состояния. Когда лучше использовать глобальную переменную, а когда достаточно возвращать новое значение наружу.
4. Соберите список типичных багов (нарушение порядка аргументов, изменение кортежа, затертая область видимости) и покажите короткие фиксы.