# Контрольная работа по Python

## Тема 1: Условные конструкции и циклы в Python 

1. Какие значения в Python считаются ложными (falsy)?
   - [ ] Только отрицательные числа
   - [x] Значения, приводимые к False
   - [ ] Только пустые строки
   - [ ] Только значение 0
   - [ ] Только None
2. Зачем используется `elif`?
   - [ ] Для остановки цикла
   - [ ] Для создания функции
   - [x] Для добавления нового условия
   - [ ] Для обработки исключений
   - [ ] Для вывода текста
3. В каком случае удобнее использовать `for`?
   - [ ] Когда нужно повторять бесконечно
   - [x] Когда известен набор значений
   - [ ] Когда условие меняется случайно
   - [ ] Когда нет итератора
   - [ ] Когда нужно ждать событие
4. В каком случае удобнее использовать `while`?
   - [ ] Когда есть список значений
   - [ ] Когда есть range
   - [x] Когда условие важно каждый раз
   - [ ] Когда нужна сортировка
   - [ ] Когда нужен словарь
5. Что делает `break`?
   - [ ] Пропускает итерацию
   - [x] Полностью прерывает цикл
   - [ ] Перезапускает цикл
   - [ ] Останавливает программу
   - [ ] Переходит в else блока
6. Что делает `continue`?
   - [x] Пропускает текущую итерацию
   - [ ] Завершает цикл полностью
   - [ ] Завершает программу
   - [ ] Переходит к else блока
   - [ ] Возвращает значение
7. Когда выполняется `else` в конструкции `for ... else`?
   - [ ] Всегда после первого шага
   - [ ] Только если был `continue`
   - [x] Если цикл завершился без `break`
   - [ ] Только если цикл пустой
   - [ ] Только при ошибке
8. Как записать тернарное выражение (условие в одну строку) в Python?
   - [ ] `if a: b else: c`
   - [ ] `a ? b : c`
   - [x] `b if a else c`
   - [ ] `if (a) {b} else {c}`
   - [ ] `b unless a else c`
9. Что такое итерация в цикле `for`?
   - [ ] Объявление переменной
   - [ ] Запуск программы
   - [x] Один проход тела цикла
   - [ ] Завершение цикла
   - [ ] Создание списка
10. Как остановить цикл `while True` изнутри цикла?
    - [ ] Использовать `pass`
    - [x] Использовать `break`
    - [ ] Использовать `continue`
    - [ ] Использовать `elif`
    - [ ] Использовать `print`

## Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры

1. Чем отличается `list.append(x)` от `list.extend(iterable)`?
   - [ ] `extend` добавляет один элемент
   - [x] `append` добавляет один элемент
   - [ ] `append` добавляет все элементы
   - [ ] `extend` удаляет элементы
   - [ ] Разницы нет
2. Как обратиться к последнему элементу списка по индексу?
   - [ ] `a[last]`
   - [ ] `a[0]`
   - [x] `a[-1]`
   - [ ] `a[1]`
   - [ ] `a[end]`
3. Что означает `start` в срезе `[start:stop:step]`?
   - [ ] Количество элементов
   - [x] Индекс начала среза
   - [ ] Индекс конца среза
   - [ ] Шаг среза
   - [ ] Тип результата
4. Что означает `stop` в срезе `[start:stop:step]`?
   - [ ] Индекс начала
   - [ ] Шаг
   - [x] Индекс конца, не включая
   - [ ] Размер списка
   - [ ] Значение элемента
5. Что означает `step` в срезе `[start:stop:step]`?
   - [ ] Индекс конца
   - [ ] Индекс начала
   - [x] Шаг выборки элементов
   - [ ] Тип списка
   - [ ] Длину списка
6. Чем отличается `list.copy()` от `list2 = list1`?
   - [x] `copy()` делает новый список
   - [ ] `copy()` связывает ссылки
   - [ ] `=` копирует элементы
   - [ ] `=` делает глубокую копию
   - [ ] Разницы нет
7. Как правильно создать список списков без «общей» вложенной ссылки?
   - [ ] `a = [[0] * 3] * 3`
   - [ ] `a = [0] * 9`
   - [x] `a = [[0] * 3 for _ in range(3)]`
   - [ ] `a = (0, 0, 0)`
   - [ ] `a = {0: 3}`
8. Что такое list comprehension?
   - [ ] Способ сортировки
   - [ ] Способ чтения файла
   - [x] Короткая запись создания списка
   - [ ] Тип словаря
   - [ ] Вид цикла while
9. Чем отличается удаление по индексу и удаление по значению в списке?
   - [ ] По значению удаляют диапазон
   - [x] По индексу удаляют позицию
   - [ ] По индексу удаляют все совпадения
   - [ ] По значению удаляют индекс
   - [ ] Разницы нет
10. Чем отличается `sort()` от `sorted()`?
    - [ ] `sorted()` меняет список
    - [x] `sort()` меняет список на месте
    - [ ] `sort()` возвращает новый список
    - [ ] `sorted()` работает только с set
    - [ ] Разницы нет

## Тема 3: Словари и множества. паттерны использования, типичные ошибки

1. Чем отличается `d.get(key)` от `d[key]`, если ключа нет?
   - [ ] `get` всегда вызывает ошибку
   - [x] `get` вернёт None по умолчанию
   - [ ] `[]` вернёт None по умолчанию
   - [ ] `get` удалит ключ
   - [ ] Разницы нет
2. Как добавить или обновить значение в словаре по ключу?
   - [ ] `d.add(k, v)`
   - [ ] `d.push(k, v)`
   - [x] `d[key] = value`
   - [ ] `d.insert(key)`
   - [ ] `d.append(value)`
3. Что возвращает `dict.keys()`?
   - [ ] Список ключей
   - [x] Представление ключей (view)
   - [ ] Пару ключ-значение
   - [ ] Только первый ключ
   - [ ] Количество ключей
4. Что возвращает `dict.values()`?
   - [ ] Список значений
   - [x] Представление значений (view)
   - [ ] Копию словаря
   - [ ] Только уникальные значения
   - [ ] Ничего не возвращает
5. Что возвращает `dict.items()`?
   - [ ] Только ключи
   - [ ] Только значения
   - [x] Представление пар (key, value)
   - [ ] Сумму элементов
   - [ ] Индексы элементов
6. Когда удобно использовать `defaultdict`?
   - [ ] Для сортировки словаря
   - [x] Для значений по умолчанию
   - [ ] Для удаления ключей
   - [ ] Для шифрования данных
   - [ ] Для чтения файла
8. Чем отличается `set` от `frozenset`?
   - [ ] `set` всегда упорядочен
   - [ ] `frozenset` поддерживает add
   - [x] `frozenset` неизменяемый
   - [ ] `set` хранит пары
   - [ ] Разницы нет
9. Какие операции множеств соответствуют: пересечение, объединение, разность?
   - [ ] `+, -, *`
   - [x] `&, |, -`
   - [ ] `and, or, not`
   - [ ] `<<, >>, ^`
   - [ ] `in, not in, is`

## Тема 4: Генераторы коллекций. list, dict, set comprehensions

1. Как выглядит list comprehension с фильтром `if`?
   - [x] `[x for x in a if x > 0]`
   - [ ] `{x for x in a if x > 0}`
   - [ ] `{k: v for k, v in a}`
   - [ ] `(x for x in a if x > 0)`
   - [ ] `for x in a: if x > 0`
2. Как выглядит dict comprehension?
   - [ ] `[k: v for k, v in pairs]`
   - [x] `{k: v for k, v in pairs}`
   - [ ] `{k, v for k, v in pairs}`
   - [ ] `(k: v for k, v in pairs)`
   - [ ] `dict(k: v for k, v in pairs)`
3. Как выглядит set comprehension?
   - [ ] `[x for x in a]`
   - [ ] `{k: v for k, v in a}`
   - [x] `{x for x in a}`
   - [ ] `(x for x in a)`
   - [ ] `set[x for x in a]`
6. Чем отличается `if/else` внутри comprehension от фильтра `if` в конце?
   - [ ] Они делают одно и то же
   - [ ] Фильтр `if` создаёт else
   - [x] `if/else` меняет значение
   - [ ] `if/else` удаляет элементы
   - [ ] Фильтр `if` всегда медленней
7. Когда comprehension лучше заменить обычным циклом `for`?
   - [ ] Когда нужен `range`
   - [ ] Когда нужен `if`
   - [x] Когда логика стала сложной
   - [ ] Когда список маленький
   - [ ] Когда есть словарь

## Тема 5: Функции. параметры, значения по умолчанию, args, kwargs, область видимости

1. Что такое позиционный аргумент при вызове функции?
   - [ ] Аргумент только в списке
   - [x] Аргумент по порядку параметров
   - [ ] Аргумент с именем
   - [ ] Аргумент из файла
   - [ ] Аргумент из словаря
2. Что такое именованный аргумент при вызове функции?
   - [ ] Аргумент с индексом
   - [ ] Аргумент только в списке
   - [x] Аргумент вида `name=value`
   - [ ] Аргумент без значения
   - [ ] Аргумент с типом str
3. Почему опасно использовать изменяемый объект (например, `[]`) как значение по умолчанию?
   - [ ] Он всегда пустой
   - [x] Он сохраняется между вызовами
   - [ ] Он запрещён в Python
   - [ ] Он медленно создаётся
   - [ ] Он ломает import
4. Для чего используется `*args`?
   - [ ] Для передачи словаря
   - [ ] Для возврата значения
   - [x] Для набора позиционных аргументов
   - [ ] Для создания класса
   - [ ] Для остановки цикла
5. Для чего используется `**kwargs`?
   - [x] Для набора именованных аргументов
   - [ ] Для набора списков
   - [ ] Для чтения файла
   - [ ] Для форматирования строки
   - [ ] Для создания модуля
6. Что означает `return` в функции?
   - [ ] Печать результата
   - [ ] Объявление переменной
   - [x] Возврат значения и выход
   - [ ] Повтор вызова
   - [ ] Импорт модуля
7. Что возвращает функция, если в ней нет `return`?
   - [ ] Пустую строку
   - [ ] False
   - [x] None
   - [ ] 0
   - [ ] Ошибку

## Тема 7: Функции args, kwargs, область видимости

1. В каком порядке обычно пишут параметры, если используются `*args` и `**kwargs`?
   - [ ] `**kwargs`, потом `*args`
   - [x] Обычные, потом `*args`, потом `**kwargs`
   - [ ] Сначала `*args`, потом обычные
   - [ ] Только `*args`, без обычных
   - [ ] Порядок не важен
2. Что произойдёт, если передать позиционный аргумент после именованного?
   - [ ] Python это игнорирует
   - [ ] Позиционный станет ключевым
   - [x] Будет ошибка синтаксиса
   - [ ] Будет предупреждение
   - [ ] Код отработает нормально
3. Как передать `*args` и `**kwargs` в другую функцию?
   - [ ] Передать как строки
   - [x] Использовать `f(*args, **kwargs)`
   - [ ] Использовать `f(args, kwargs)`
   - [ ] Использовать `f(&args, &kwargs)`
   - [ ] Использовать `f(*kwargs, **args)`
4. Что такое локальная область видимости?
   - [ ] Переменные из модуля
   - [x] Переменные внутри функции
   - [ ] Переменные в файле
   - [ ] Переменные в классе всегда
   - [ ] Переменные в библиотеке
5. Что такое глобальная область видимости?
   - [ ] Переменные внутри цикла
   - [x] Переменные на уровне модуля
   - [ ] Переменные внутри if
   - [ ] Переменные внутри списка
   - [ ] Переменные внутри lambda
6. Что делает `global`?
   - [ ] Создаёт новый модуль
   - [ ] Делает переменную локальной
   - [x] Разрешает менять глобальную
   - [ ] Удаляет переменные
   - [ ] Копирует значение
7. Что делает `nonlocal`?
   - [ ] Делает переменную глобальной
   - [x] Берёт из внешней функции
   - [ ] Удаляет переменную
   - [ ] Делает переменную константой
   - [ ] Создаёт новый параметр

## Тема 8: Сложность алгоритмов. Big O

1. Что означает сложность O(1)?
   - [x] Время не зависит от n
   - [ ] Время равно n
   - [ ] Время равно n²
   - [ ] Время равно log n
   - [ ] Время всегда растёт
2. Что означает сложность O(n)?
   - [ ] Время не меняется
   - [x] Время растёт линейно
   - [ ] Время растёт квадратно
   - [ ] Время растёт логарифмически
   - [ ] Время зависит от памяти
3. Что означает сложность O(log n)?
   - [ ] Время равно n
   - [ ] Время равно n²
   - [x] Время растёт как log n
   - [ ] Время всегда O(1)
   - [ ] Время не измеряют
4. Какая сложность обычно у двух вложенных циклов по `n` элементов?
   - [ ] O(1)
   - [ ] O(n)
   - [x] O(n²)
   - [ ] O(log n)
   - [ ] O(n log n)
5. Что означает «амортизированная сложность» на примере `list.append()`?
   - [ ] Всегда O(n)
   - [x] В среднем близко к O(1)
   - [ ] Всегда O(n²)
   - [ ] Всегда O(log n)
   - [ ] Не измеряется
6. Что такое пространственно-временной компромисс (время vs память)?
   - [ ] Выбор шрифта
   - [ ] Выбор версии Python
   - [x] Быстрее за счёт памяти
   - [ ] Меньше памяти без затрат
   - [ ] Нельзя менять память
7. Какое общее изменение часто снижает сложность с O(n²) до O(n log n)?
   - [ ] Добавить print
   - [x] Использовать сортировку/разделение
   - [ ] Убрать переменные
   - [ ] Использовать float
   - [ ] Заменить if на elif

## Тема 9: Алгоритмы и структуры данных

1. Что такое стек (stack)?
   - [ ] FIFO структура
   - [x] LIFO структура
   - [ ] Хеш-таблица
   - [ ] Дерево поиска
   - [ ] Граф
2. Что такое очередь (queue)?
   - [x] FIFO структура
   - [ ] LIFO структура
   - [ ] Дерево
   - [ ] Множество
   - [ ] Словарь
3. Какая сложность у двоичного поиска в отсортированном списке?
   - [ ] O(1)
   - [ ] O(n)
   - [x] O(log n)
   - [ ] O(n²)
   - [ ] O(n log n)
4. Какая средняя сложность у быстрой сортировки (quicksort)?
   - [ ] O(1)
   - [ ] O(n)
   - [x] O(n log n)
   - [ ] O(n²)
   - [ ] O(log n)

## Тема 10: Работа с файлами

1. Что означает режим открытия файла `'r'`?
   - [x] Чтение существующего файла
   - [ ] Запись с очисткой файла
   - [ ] Добавление в конец файла
   - [ ] Чтение и запись всегда
   - [ ] Создание нового файла
3. Что означает режим открытия файла `'r+'`?
   - [ ] Только запись
   - [ ] Только чтение
   - [x] Чтение и запись без очистки
   - [ ] Добавление в конец
   - [ ] Создание файла всегда
4. Как открыть файл так, чтобы он закрылся автоматически?
   - [ ] Через `print()`
   - [x] Через `with open(...) as f:`
   - [ ] Через `input()`
   - [ ] Через `def open_file():`
   - [ ] Через `import open`
5. Что такое контекстный менеджер при работе с файлами?
   - [ ] Функция чтения
   - [x] Объект для `with` блока
   - [ ] Формат файла
   - [ ] Вид переменной
   - [ ] Режим кодировки
6. Как читать большой файл построчно, не загружая его целиком в память?
   - [ ] `f.read()`
   - [ ] `f.readlines()`
   - [x] `for line in f:`
   - [ ] `f.write()`
   - [ ] `f.seek(0)`
7. Чем отличаются `read()`, `readline()`, `readlines()`?
   - [ ] Они одинаковые
   - [x] Разный объём чтения
   - [ ] Только для бинарных
   - [ ] Только для JSON
   - [ ] Зависит от ОС
8. Как проверить, что файл существует, до попытки чтения?
   - [ ] `file.exists()`
   - [ ] `open.exists(path)`
   - [x] `Path(path).exists()`
   - [ ] `print(path)`
   - [ ] `len(path) > 0`
9.  Зачем указывать `encoding` при открытии текстового файла?
    - [ ] Для ускорения чтения
    - [ ] Для сжатия файла
    - [x] Для правильной кодировки текста
    - [ ] Для сортировки строк
    - [ ] Для запрета записи

## Тема 11: ООП (урок 47)

1. Что такое класс в ООП?
   - [ ] Конкретный объект
   - [x] Шаблон для объектов
   - [ ] Файл с кодом
   - [ ] Имя функции
   - [ ] Тип цикла
2. Что такое объект (экземпляр класса)?
   - [x] Созданный экземпляр класса
   - [ ] Описание класса
   - [ ] Модуль Python
   - [ ] Тип данных int
   - [ ] Режим файла
3. Для чего нужен метод `__init__`?
   - [ ] Для удаления объекта
   - [x] Для инициализации объекта
   - [ ] Для печати объекта
   - [ ] Для импорта модулей
   - [ ] Для сортировки списка
4. Что означает `self` в методах класса?
   - [x] Ссылка на текущий объект
   - [ ] Ссылка на модуль
   - [ ] Ссылка на функцию
   - [ ] Ссылка на список
   - [ ] Ссылка на файл
5. Что такое наследование?
   - [ ] Скрытие данных
   - [ ] Перегрузка операторов
   - [x] Получение свойств родителя
   - [ ] Чтение из файла
   - [ ] Сортировка массива
6. Что такое инкапсуляция?
   - [ ] Повтор кода
   - [x] Сокрытие деталей реализации
   - [ ] Быстрая сортировка
   - [ ] Поиск в словаре
   - [ ] Чтение из stdin
7. Что такое полиморфизм?
   - [ ] Один метод для одного класса
   - [x] Разное поведение при одном интерфейсе
   - [ ] Только множественное наследование
   - [ ] Только инкапсуляция
   - [ ] Только генераторы
10. Для чего используют `super()`?
    - [ ] Для создания списка
    - [x] Для вызова метода родителя
    - [ ] Для выхода из функции
    - [ ] Для чтения файла
    - [ ] Для поиска элемента
11. Что такое множественное наследование?
    - [ ] Наследование без методов
    - [x] Наследование от нескольких классов
    - [ ] Наследование только от object
    - [ ] Наследование только атрибутов
    - [ ] Наследование без init
12. Чем отличаются атрибуты класса и атрибуты экземпляра?
    - [ ] Они всегда одинаковые
    - [ ] Атрибуты класса хранятся в списке
    - [x] Класс общий, экземпляр свой
    - [ ] Экземпляр доступен только внутри класса
    - [ ] Атрибуты класса нельзя читать