# Урок 31. Словари и множества. паттерны использования, типичные ошибки

## Цель урока
К концу урока вы поймете зачем нужны словари и множества и как они помогают быстро искать данные. Научитесь добавлять и удалять элементы без ошибок и проверять что объекты остаются уникальными. Сможете собрать простую аналитику по тексту с помощью этих структур.

## Ключевые понятия
- Словарь
  - Коллекция пар ключ и значение. ключ уникален и должен быть неизменяемым типом, например строкой или числом.
  - Доступ по ключу дает результат почти мгновенно без перебора всех элементов.
- Методы словаря
  - `get` спокойно возвращает значение и позволяет указать запасное значение если ключа нет.
  - `update`, `pop`, `setdefault` помогают изменять словарь и избегать ошибок `KeyError`.
- Множество
  - Набор уникальных элементов без повторов. порядок не важен. используется для быстрого теста принадлежности.
  - Создается через `set()` или фигурные скобки. но пустые скобки `{}` создают словарь, поэтому важно помнить про `set()`.
- Операции множеств
  - Объединение, пересечение, разность и симметрическая разность помогают сравнивать наборы данных.
- Паттерны использования
  - Подсчет частоты событий через словарь.
  - Проверка уникальности и удаление дублей через множество.
  - Комбинация этих структур для сборки мини аналитики.

## Содержание темы

### Блок 1. Словарь как структура быстрого доступа
Словарь отвечает на вопрос как найти нужные данные по понятному ключу. Например по логину пользователя или названию товара. Вместо того чтобы перебирать список, словарь запоминает позицию значения и отдаёт его сразу. Чтобы создать словарь, используйте литерал `{}` с парами "ключ": "значение" или функцию `dict()` с последовательностью кортежей. Ключи должны быть неизменяемыми объектами. Если попробовать передать список, Python выдаст ошибку `TypeError`.

```python
# создаем словарь пользователя
user = {
    "login": "olia",
    "age": 19,
    "city": "Perm"
}

print(user["login"])      # выводим логин
print(user.get("email"))   # вернет None, потому что ключа нет
print(user.get("email", "нет данных"))
```
`get` полезен тем, что не ломает программу при отсутствии ключа и сразу возвращает понятную подпись. Это особенно важно в начале обучения, когда ошибки отвлекают от сути задачи.

Пример из жизни. Вы ведете список контактов друзей. Логин выступает ключом, значение хранит телефон и любимый кофе. Словарь позволяет мгновенно узнать заказ друга без поиска по всему списку.

### Блок 2. Мутация словарей и обработка ошибок
Когда словарь уже создан, нужно аккуратно обновлять данные и поддерживать их в актуальном состоянии. Для подсчета заказов по пользователям удобно пользоваться `setdefault` или `get`. Эти методы сразу создают значение по умолчанию, если ключ еще не появлялся. Удаляя элементы, проговаривайте себе что будет если ключа нет. `pop` может принять запасное значение и вернуть его вместо того чтобы бросить `KeyError`.

```python
orders = {}

def add_order(login, cost):
    orders[login] = orders.get(login, 0) + cost  # накапливаем сумму

add_order("olia", 300)
add_order("olia", 500)
add_order("dima", 200)

spent = orders.pop("masha", 0)  # безопасное удаление
print(spent)  # выведет 0, потому что не нашли ключ
print(orders)
```
Если в словаре лежат списки или другие изменяемые объекты, помните что метод `setdefault` возвращает ссылку на один и тот же список. Поэтому перед добавлением можно создавать копию через `list()` или `copy()`.

Пример из жизни. У курьера есть словарь "посылка → список действий". Если две посылки получают одинаковую ссылку на список, изменения одного списка затронут обе посылки. Чтобы избежать путаницы, курьер копирует список перед редактированием.

### Блок 3. Множества и проверки уникальности
Множество похоже на коробку с карточками без повторов. Добавляя элемент, вы автоматически избавляетесь от дубликатов. Проверка `if item in my_set` работает очень быстро, потому что Python хранит внутренний хэш каждого элемента. Создавая пустое множество, используйте `set()`, потому что `{}` создаёт пустой словарь.

```python
emails = ["anna@mail.ru", "bob@mail.ru", "anna@gmail.com"]
domains = {email.split('@')[1] for email in emails}  # множество доменов

print(domains)
print("mail.ru" in domains)

allowed = {"company.com", "mail.ru"}
print(domains & allowed)   # пересечение множеств
```
Операции `|`, `&`, `-` и `^` позволяют сравнивать наборы данных. Они удобны при проверке прав доступа, списков участников и сегментов рассылок.

Пример из жизни. На мероприятии каждому участнику выдают браслет. Сканер считывает ID и добавляет его в множество. Повторный вход не создаст дубли, потому что такое значение уже существует.

### Блок 4. Паттерны словарей и множеств в мини проекте
В реальных задачах словари и множества живут вместе. Например нам приходит список сообщений из чата. Мы хотим посчитать сколько сообщений написал каждый пользователь, выделить активных участников и убрать спам. Словарь отлично хранит число сообщений на пользователя. Множество фиксирует тех кто превысил лимит или список стоп слов. Такие паттерны станут базой для следующего урока про генераторы коллекций. Важно держать код читабельным. Если формула становится слишком длинной, разбейте ее на несколько отдельных шагов.

```python
messages = [
    {"user": "olia", "text": "Привет"},
    {"user": "dima", "text": "Заказ оформлен"},
    {"user": "olia", "text": "Нужен счет"},
]

counts = {}
active_users = set()

for message in messages:
    user = message["user"]
    counts[user] = counts.get(user, 0) + 1
    if counts[user] > 1:
        active_users.add(user)

print(counts)
print(active_users)
```
Такой подход помогает быстро собрать отчет и подготовить данные для визуализации или последующей фильтрации comprehension конструкциями.

Пример из жизни. Команда поддержки наблюдает активность в чате интернет магазина. Если пользователь пишет больше пяти сообщений в день, его автоматически переносит в набор `active_users` и менеджер получает уведомление.

## Объединяющий пример
Представим сервис доставки еды. Нам приходит список заказов, и нужно понять кто что заказал, сколько потратил, какие города активнее всего. Решим задачу в несколько шагов, комбинируя словари и множества.

1. Соберем словарь с суммой заказов по каждому пользователю.
2. Найдем множество городов где оформлены заказы.
3. Отберем активных клиентов по порогу трат.

```python
orders = [
    {"user": "olia", "city": "Пермь", "total": 900},
    {"user": "dima", "city": "Москва", "total": 450},
    {"user": "olia", "city": "Пермь", "total": 300},
    {"user": "inna", "city": "Самара", "total": 700}
]

spent_by_user = {}
cities = set()
active_users = set()

for order in orders:
    user = order["user"]
    city = order["city"]
    total = order["total"]

    spent_by_user[user] = spent_by_user.get(user, 0) + total
    cities.add(city)

for user, total in spent_by_user.items():
    if total >= 800:
        active_users.add(user)

print(spent_by_user)
print(cities)
print(active_users)
```
Сначала мы используем словарь, чтобы аккумулировать суммы. Метод `get` обеспечивает создание записи даже для первого заказа. Затем множество `cities` показывает географию заказов без повторов. В конце мы строим множество активных клиентов и можем, например, отправить им бонус. Такой пример объединяет ключевые идеи урока и показывает логику перехода к следующим темам.
